# Stalled

So I pushed pretty hard into this direction of separating the logic
from the underlying representation of state, and it's "good" in the
sense that the domain code ends up being really clean -- the nitty
gritty details of what things mean is hidden down in the value atoms.

But it's also feeling a bit forced; so I want to step back and try
again.

Important lessons on this spike

* The outside in approach works

* The problem statement has a lot of vocabulary in it; you can align
your nouns with the language of the problem as described, or with
what you imagine the problem to be.  Because the problem statement
isn't entirely consistent, there are some difficulties

* A single entry point for tests makes calibration really easy.

* Identifying decisions is valuble, because they show you where
the module boundaries are.  You can taken an entire chunk of working
but ugly code and get it out of sight, virtuously.

* Eliminating duplication is over rated.